---
title: 'Intro to R: Day 2 Part 1'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data frame manipulation with dplyr
<https://swcarpentry.github.io/r-novice-gapminder/13-dplyr/index.html>

### Summary statistics using **base R** operations  

```{r}
gapminder <- read.csv("data/gapminder_data.csv", stringsAsFactors = TRUE)
mean(gapminder[gapminder$continent == "Africa", "gdpPercap"]) 
```


```{r}
gapminder <- read.csv("data/gapminder_data.csv", stringsAsFactors = TRUE)
mean(gapminder[gapminder$continent == "Americas", "gdpPercap"])
```

## the **dplyr** package

###The five most commonly used functions, and **%>%**    

* select() 
* filter() 
* groub_by() 
* summarize() 
* mutate() 

### Installing dplyr package  
```
install.packages('dplyr')   note: does ' or " matter 
```

### Loading the package  
```
library("dplyr")
```

### The select() function 

![](images/13-dplyr-fig1.png)

Select columns: 

```
head(select(gapminder, year, country, gdpPercap))
```

Select columns and save to a new dataframe   

```
year_country_gdp <- select(gapminder, year, country, gdpPercap)
```

### Removing a column

```
smaller_gapminder_data <- select(gapminder, -continent)
```

### Removing a column using **dplyr** and **pipes (%>%)**  
```
year_country_gdp <- gapminder %>% select(year, country, gdpPercap)
```

### Renaming columns in a dataframe 

Syntax: **rename(new_name = old_name)**  

```
tidy_gdp <- year_country_gdp %>% rename(gdp_per_capita = gdpPercap)
```  

### Using the filter() function

As the name suggests, filter out everything but the data you want.  

Using filter combined with select:  
```
year_country_gdp_euro <- gapminder %>% 
  filter(continent == "Europe") %<% 
  select(year, country, gdpPercap) 
```

Adding a filter for specific year: 
```
year_country_gdp_euro <- gapminder %>% 
  filter(continent == "Europe", year == 2007) %<% 
  select(year, country, gdpPercap) 
```
### Challenge 1  

Write a single command (which can span multiple lines and includes pipes) that will produce a dataframe that has the **African** values for **lifeExp**, **country** and **year**, but not for the other Continents.
How many rows does your data frame have, and why?


### Using the group_by function  

Avoid error-prone repetitiveness. Rather then cutting and pasting the above code for each continent use the group_by function.

```
gapminder %>% group_by(continent)

str(gapminder %>% group_by(continent)) 
```

## Using the summarize function  

*group_by* is often used in conunction with *summarize()*

- first split the data frame into multiple pieces with *group_by()*   
- then pipe that data into other functions such as *mean()* or *sd()* within *summarize()*  

``` 
gdp_bycontinents <- gapminder %>% 
  group_by(continent) %>% 
  summarize(mean_gdpPercap = mean(gdpPercap))
```

## the arrange() function  
This *dplyr* function arranges the rows in a dataframe according to one or more variables from the dataframe.

arrange() works on alphanumerics as well as numbers.

syntax: arrange(variable)

Use desc() within arrange() for reverse order

syntax:  arrange(desc(variable))


### Challenge 2  
- Calculate the average life expectancy per country. 
- Which has the longest average life expectancy and which has the shortest average life expectancy?  


## The group_by() functins allows us to group by multiple variables.  

Looking at an earlier example:  
```
gapminder %>% 
  group_by(continent) %>% 
  summarize(mean_gdpPercap = mean(gdpPercap))
```

You are not limited to one group_by variable: 
```
gapminder %>% 
  group_by(continent, year) %>% 
  summarize(mean_gdpPercap = mean(gdpPercap),
      sd_gdpPercap = sd(gdpPercap),
      mean_pop = mean(pop),
      sd_pop = sd(pop))  
```  


## The count() and n() functions  

*count()* counts the number of observations for each group  
```
gapminder %>% 
  filter(year == 2002) %>% 
  count(continent, sort = TRUE) 
```
*sort:* If TRUE, will show the largest groups at the top.  

*name:* The name of the new column in the output. If omitted, it will default to n. If there's already a column called n, it will error, and require you to specify the name.  

*n()* returns the number of observations in the current group *rather* than counting observations.

```
gapminder %>% 
  group_by(continent) %>% 
  summarize(sd_le = sd(lifeExp)/sqrt(n()))
```

You can probably see by now that the power of dplyr is the ability to chain several summary operations together.

For example: minimum, maximum, mean and se for each continent's per-country life-expectancy.

```
gapminder %>% 
  group_by(continent) %>% 
  summarize(
    mean_le = mean(lifeExp),
    min_le = min(lifeExp),
    max_le = max(lifeExp),
    sd_le = sd(lifeExp)) 
```

## Using the mutate() function to create new variables

You can create new variables prior to or even after summarizing information with mutate().

```
gapminder %>%
    mutate(gdp_billion = gdpPercap*pop/10^9) %>%
    group_by(continent, year) %>% 
    summarize(
      mean_gdpPercap = mean(gdpPercap),
      sd_gdpPercap = sd(gdpPercap),
      mean_pop = mean(pop),
      sd_pop = sd(pop),
      mean_gdp_billion = mean(gdp_billion),
      sd_gdp_billion = sd(gdp_billion))
```

## Connect mutate with logical filtering: ifelse   

